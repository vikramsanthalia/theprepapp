{
  "name": "vertica",
  "version": "0.4.2",
  "description": "Pure Javascript client library for Vertica",
  "keywords": [
    "database",
    "vertica",
    "sql"
  ],
  "author": {
    "name": "Willem van Bergen",
    "email": "willem@railsdoctors.com"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://opensource.org/licenses/mit-license.php"
    }
  ],
  "maintainers": [
    {
      "name": "Willem van Bergen",
      "email": "willem@railsdoctors.com",
      "url": "http://www.vanbergen.org"
    }
  ],
  "devDependencies": {
    "coffee-script": "~> 1.6.2",
    "vows": "~> 0.7.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/wvanbergen/node-vertica.git"
  },
  "main": "./lib/vertica",
  "directories": {
    "lib": "./lib",
    "src": "./src",
    "test": "./test"
  },
  "engine": {
    "node": ">= 0.8"
  },
  "scripts": {
    "prepublish": "cake clean && cake build",
    "test": "vows test/*.coffee"
  },
  "readme": "# node-vertica\n\nA pure javascript library to connect to a Vertica database. Except that it is written in CoffeeScript.\n\n## Installation\n\n    npm install vertica\n\n## Getting started\n\n### Connecting\n\nCall the `connect` method with a connection options object. The following connection\noptions are supported.\n\n- `host`: the host to connect to (default: `\"localhost\"`)\n- `port`: the remote port to connect to (default: `5433`)\n- `user`: the username to use for authentication\n- `password`: the password to use for authentication\n- `database`: the database to connect to. If your Vertica server only has a single\n  database, you can leave this blank.\n- `ssl`: whether to encrypt the connection using SSL. The following values are supported:\n    - `false`: no SSL\n    - `\"optional\"`: use SSL if the server supports it, but fall back to no SSL if not (default).\n    - `\"required\"`: use SSL, throw an error if the server doesn't support it.\n    - `\"verified\"`: use SSL, throw an error if the server doesn't support it or its SSL\n      certificate could not be verified.\n- `role`: Runs a `SET ROLE` query to activate a role for the user immediately after connecting.\n- `searchPath`: Runs a `SET SEARCH_PATH TO` query to set the search path after connecting.\n- `timezone`: Runs a `SET TIMEZONE TO` query to set the connection's time zone after connecting.\n- `initializer`: a callback function that gets called after connection but before any query\n  gets executed.\n- `decoders`: an object containing custom buffer decoders for query result field deserialization, see usage in custom decoders test.\n\n```coffeescript\n\nVertica = require 'vertica'\nconnection = Vertica.connect host: 'localhost', user: \"me\", password: 'secret', (err) ->\n  throw err if err\n```\n\n*Note:* the `connect` will establish a single connection. A connection can only execute\none query at the time. Due to the evented nature of node.js, it is possible to start a new\nquery while another query is still running. This library implements a simple queueing\nsystem that will run queries serially.\n\nIf you want parallelism, you will need multiple connections to your server. You can set up\nconnection pooling fairly easily using the `generic-pool` library. Note that transactions\ncannot be shared between multiple connections; you need to use the same connection for all\nqueries in the transaction and run them in serial.\n\n#### Example Create Function for `generic-pool`\n```coffeescript\npool = genericPool.Pool(\n  create: (callback) ->\n    vertica.connect {}, (err, conn) ->\n      callback err, conn\n)\n```\n\n### Querying (buffered)\n\nRunning a buffered query will assemble the result in memory and call the callback\nfunction when it is completed.\n\n```coffeescript\n\nconnection = Vertica.connect(...)\nconnection.query \"SELECT * FROM table\", (err, resultset) ->\n  console.log err, resultset.fields, resultset.rows, resultset.status\n\n# or, identically:\n\nquery = Vertica.connect(...).query \"SELECT * FROM table\"\nquery.callback = (err, resultset) -> ...\n```\n\n### Querying (unbuffered)\n\nRunning an unbuffered query will immediately emit incoming data as events and\nwill not store the result in memory. Recommended for handling huge resultsets.\n\n```coffeescript\n\nconnection = Vertica.connect(...)\nquery = connection.query \"SELECT * FROM table\"\n\n# 'fields' is emitted once.\nquery.on 'fields', (fields) -> console.log(\"Fields:\", fields)\n\n# 'row' is emitted 0..* times, once for every row in the resultset.\nquery.on 'row', (row) -> console.log(row)\n\n# 'end' is emitted once.\nquery.on 'end', (status) -> console.log(\"Finished!\", status)\n\n# If 'error' is emitted, no more events will follow.\n# If no event handler is implemented, an exceptions gets thrown instead.\nquery.on 'error', (err) -> console.log(\"Uh oh!\", err)\n```\n\n## About\n\n- MIT licensed (see LICENSE).\n- Written by Willem van Bergen for Shopify Inc.\n- Pull requests are gladly accepted. Please modify the CoffeeScript source files\n  in the `/src` folder, and not the compiled JavaScript output files.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/wvanbergen/node-vertica/issues"
  },
  "homepage": "https://github.com/wvanbergen/node-vertica",
  "_id": "vertica@0.4.2",
  "_from": "vertica@~0.4.1"
}
